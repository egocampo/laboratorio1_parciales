/*
 * informes.c
 *
 *  Created on: 30 abr. 2021
 *      Author: gabriel
 */

#include <stdio.h>
#include <stdio_ext.h>
#include <stdlib.h>
#include <string.h>
#include "gets.h"
#include "validations.h"
#include "cliente.h"
#include "compra.h"
#include "funcionesComunes.h"
#include "informes.h"
#define CANT_COMPRAS 1000
#define PENDIENTE 1
#define COBRADO 0

int informes_cantidadComprasPendientes(Compra* listadoCompras, int lenCompras)
{
	int returnFuncion = -1;
	int i;
	int contadorComprasPendientes = 0;
	if(listadoCompras != NULL && lenCompras > 0)
	{
		returnFuncion = 0;
		system("clear");
		printf("Cantidad de compras en estado \"PENDIENTE\"\n\n");
		for(i=0;i<lenCompras;i++)
		{
			if(listadoCompras[i].estadoDelCobro==PENDIENTE && listadoCompras[i].isEmpty == 0)
			{
				contadorComprasPendientes++;
			}
		}
		printf("La cantidad de compras pendientes es: %d\n\nPresione cualquier tecla para continuar...",contadorComprasPendientes);
		getchar();
	}
	return returnFuncion;
}

int informes_compraPrecioPorUnidadMasBajo(Compra* listadoCompras, int lenCompras)
{
	int returnFunction = -1;
	int indiceCompraPrecioPorUnidadMasBajo;
	if(listadoCompras != NULL && lenCompras > 0)
	{
		returnFunction = 0;
		informes_calcularPreciosPorUnidad(listadoCompras, lenCompras);
		informes_buscarPosicionDeMinimoPrecioPorUnidad(listadoCompras, lenCompras, 0, &indiceCompraPrecioPorUnidadMasBajo);
		system("clear");
		printf("Compra con precio por unidad mas bajo\n\n");
		if(listadoCompras[indiceCompraPrecioPorUnidadMasBajo].estadoDelCobro == COBRADO)
		{
			compra_imprimirCompraPorIndice(listadoCompras, indiceCompraPrecioPorUnidadMasBajo);
			printf(" ⸠—El importe abonado es: $ %.2f\n ⸠—El precio por unidad es: $ %.2f\n\n",listadoCompras[indiceCompraPrecioPorUnidadMasBajo].importePagado,listadoCompras[indiceCompraPrecioPorUnidadMasBajo].precioPorUnidad);
		}
		else
		{
			printf("No hay compras con estado \"COBRADA\".\n\n");
		}
		printf("Presione cualquier tecla para continuar...");
		getchar();
	}
	return returnFunction;
}

int informes_calcularPreciosPorUnidad(Compra* listadoCompras, int lenCompras)
{
	int returnFunction = -1;
	int i;
	if(listadoCompras != NULL && lenCompras > 0)
	{
		returnFunction = 0;
		for(i=0;i<lenCompras;i++)
		{
			if(listadoCompras[i].isEmpty == 0 && listadoCompras[i].estadoDelCobro == COBRADO)
			{
				listadoCompras[i].precioPorUnidad = listadoCompras[i].importePagado / listadoCompras[i].cantidadDeBarbijos;
			}
		}
	}
	return returnFunction;
}

int informes_buscarPosicionDeMinimoPrecioPorUnidad(Compra* listadoCompras, int lenCompras, int inicial,int* pPosicionRetorno)
{
	int retorno = -1;
	int posicionDelMinimoPrecioPorUnidad = inicial;
	int i;
	float minimoPrecioPorUnidad = listadoCompras[inicial].precioPorUnidad;
	if(listadoCompras != NULL && lenCompras > 0)
	{
		retorno = 0;
		for(i=inicial;i<lenCompras;i++)
		{
			if(listadoCompras[i].isEmpty == 0 && listadoCompras[i].estadoDelCobro == COBRADO)
			{
				if(listadoCompras[i].precioPorUnidad < minimoPrecioPorUnidad)
				{
					minimoPrecioPorUnidad = listadoCompras[i].precioPorUnidad;
					posicionDelMinimoPrecioPorUnidad = i;
				}
			}
		}
		*pPosicionRetorno = posicionDelMinimoPrecioPorUnidad;
	}
	return retorno;
}

//------------------------------------------------------------

int informes_colorBarbijoMasVeces(Compra* listadoCompras, int lenCompras)
{
	int returnFunction = -1;
	int contadorIdColores = 1;
	if(listadoCompras != NULL && lenCompras > 0)
	{
		returnFunction = 0;
		Colores listadoColores[lenCompras];
		informes_inicializarColores(listadoColores, lenCompras);
		informes_generarListadoColores(listadoCompras, lenCompras, listadoColores, &contadorIdColores);
		informes_contarComprasPorColor(listadoCompras, lenCompras, listadoColores);

		for(int i=0;i<10;i++)
			printf("Indice: %d\tId: %d\tColor: %s\tCant: %d\tIsEmpty: %d\n",i,listadoColores[i].idColor,listadoColores[i].color,listadoColores[i].cantidadCompras,listadoColores[i].isEmpty);
	}
	return returnFunction;
}

int informes_contarComprasPorColor(Compra* listadoCompras, int lenCompras, Colores* listadoColores)
{
	int returnFunction = -1;
	int i,j;
	if(listadoCompras != NULL && lenCompras > 0 && listadoColores != NULL)
	{
		returnFunction = 0;
		for(i=0;i<lenCompras;i++)
		{
			if(listadoColores[i].isEmpty == 0)
			{
				for(j=0;j<lenCompras;j++)
				{
					if(strncmp(listadoColores[i].color,listadoCompras[j].color,32) == 0)
					{
						listadoColores[i].cantidadCompras += 1;
					}
				}
			}
		}
	}
	return returnFunction;
}

int informes_inicializarColores(Colores* listadoColores, int lenColores)
{
	int returnFunction = -1;
	int i;
	if(listadoColores != NULL && lenColores > 0)
	{
		returnFunction = 0;
		for(i=0;i<lenColores;i++)
		{
			strncpy(listadoColores[i].color,"",32);
			listadoColores[i].cantidadCompras = 0;
			listadoColores[i].isEmpty = 1;
		}
	}
	return returnFunction;
}

int informes_generarListadoColores(Compra* listadoCompras, int lenCompras, Colores* listadoColores, int* contadorIdColores)
{
	int flagExiste;
	int i,j;
	int primerIndiceVacioColores;
	if(listadoCompras != NULL && lenCompras > 0 && listadoColores != NULL)
	{
		flagExiste = 0;
		for(i=0;i<lenCompras;i++)
		{
			if(listadoCompras[i].isEmpty == 0)
			{
				for(j=0;j<lenCompras;j++)
				{
					if(strncmp(listadoCompras[i].color,listadoColores[j].color,32) == 0)
					{
						flagExiste = 1;
						break;
					}
				}
				if(flagExiste == 0)
				{
					primerIndiceVacioColores = informes_buscarIndexEmptyColores(listadoColores, lenCompras);
					strncpy(listadoColores[primerIndiceVacioColores].color,listadoCompras[i].color,32);
					listadoColores[primerIndiceVacioColores].isEmpty = 0;
					listadoColores[primerIndiceVacioColores].idColor = *contadorIdColores;
					(*contadorIdColores)++;
				}
			}
		}

	}
	return flagExiste;
}

int informes_buscarIndexEmptyColores(Colores* listadoColores, int lenColores)
{
	int returnFunction = -2;
	int i;
	if(listadoColores != NULL && lenColores > 0)
	{
		returnFunction = -1;
		for(i=0;i<lenColores;i++)
		{
			if(listadoColores[i].isEmpty == 1)
			{
				returnFunction = i;
				break;
			}
		}
	}
	return returnFunction;
}

int informes_buscarIndiceMaximoColor(Colores* listadoCompras, int lenCompras,int indiceInicial)
{
	int indiceMaximoColor;
	int i, valorMaximo;
	if(listadoCompras != NULL && lenCompras > 0)
	{
		indiceMaximoColor = indiceInicial;
		valorMaximo = listadoCompras[indiceInicial].cantidadCompras;
		for(i=indiceInicial;i<lenCompras;i++)
		{
			if(listadoCompras[i].cantidadCompras > valorMaximo)
			{
				valorMaximo = listadoCompras[i].cantidadCompras;
				indiceMaximoColor = i;
			}
		}
	}
	return indiceMaximoColor;
}

char informes_buscarColorPorIndice(Colores* listadoColores, int lenColores)
{
	char colorMasVendido
	return colorMasVendido;
}




